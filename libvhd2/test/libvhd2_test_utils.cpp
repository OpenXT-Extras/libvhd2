/*
 * Copyright (c) 2012 Citrix Systems, Inc.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

/**
    @file   Some Libvhd2 test utilites / sunctions
*/



#include <stdio.h>
#include <assert.h>

#include <string>
using std::string;

#include <vector>
using std::vector;

#include "libvhd2_test.h"

#include "../include/libvhd2.h"

//####################################################################
//# class TRndSequenceGen implementation
//####################################################################


/** @param aRndSeed - random seed for sequence initialisation */
void TRndSequenceGen::InitRndSeed(uint aRndSeed)
{
    test(aRndSeed);
    iSeed = aRndSeed;

    //srand(aRndSeed);
}

/**
    Generate a pseudo-random sequence and put it into a buffer.

    @param  apBuf   buffer
    @param  aBytes  number of bytes to generate. must be a multiple of 4

    @pre    random seed should be set before, see InitRndSeed()
*/
void TRndSequenceGen::GenerateSequence(void* apBuf, uint aBytes)
{
    //-- can deal with a sequence that is a multiple of word long.
    test(aBytes && !(aBytes % sizeof(int)));

    //-- use random seed that is set before
    int* pBuf = (int*)apBuf;
    for(uint i=0; i<(aBytes/sizeof(int)); ++i)
    {
        //-- the sequence isn't very nice, depends on RAND_MAX. But it should be OK for this purpose
        const int val1 = rand_r(&iSeed);
        pBuf[i] = val1;
    }
}

/**
    Check a pseudo-random sequence and from a buffer.

    @param  apBuf   buffer with teh data
    @param  aBytes  number of bytes to check. must be a multiple of 4
    @return KErrNone if the sequence in the buffer is the same as generated; KErrCorrupt otherwise

    @pre    random seed should be set before, see InitRndSeed()
*/
int TRndSequenceGen::CheckSequence(const void* apBuf, uint aBytes)
{
    //-- can deal with a sequence that is a multiple of word long.
    test(aBytes && !(aBytes % sizeof(int)));

    //-- use random seed that is set before
    const int* pBuf = (const int*)apBuf;
    for(uint i=0; i<(aBytes/sizeof(int)); ++i)
    {
        const int val1 = pBuf[i];
        const int val2 = rand_r(&iSeed);

        if(val1 != val2)
            return KErrCorrupt;

    }

    return KErrNone;
}

/**
    "skips" bytes in the sequence by simply calling rand()
    @param  aBytes how many bytes need to be skipped
*/
void TRndSequenceGen::SkipSequence(uint aBytes)
{
    test(aBytes && !(aBytes % sizeof(int)));

    for(uint i=0; i<(aBytes/sizeof(int)); ++i)
        rand_r(&iSeed);
}



//--------------------------------------------------------------------
void LibVhd_2_CloseVhd(TVhdHandle& aVhdHandle)
{
    TEST_LOG("handle:%d", aVhdHandle);
    test(aVhdHandle > 0);

    int nRes = VHD_Flush(aVhdHandle);
    test_KErrNone(nRes);

    VHD_Close(aVhdHandle);
    aVhdHandle = 0;
}



//--------------------------------------------------------------------
/**
    Read a number of sectors from a VHD file and verify that they are filled with the given byte.
    "libvhd2" is used.

    @param  aVhdHandle      VHD file file handle
    @param  aStartSector    statring sector
    @param  aNumSectors     number of secttors to read/verify
    @param  aFill           required filling byte

    @return KErrNone if the read sequence is the same as generated by aSeqGen. KErrCorrupt otherwise
*/
int LibVhd_2_CheckFileFill(TVhdHandle aVhdHandle, uint aStartSector, uint aNumSectors, uint8_t aFill)
{
    TEST_LOG("vhdHandle:%d, aStartSector:%d, aNumSectors:%d, Fill:%d", aVhdHandle, aStartSector, aNumSectors, aFill);

    test(aVhdHandle > 0);
    test(aNumSectors > 0);

    int nRes;
    uint8_t buf[32*K1KiloByte];

    uint remSectors = aNumSectors;
    uint currSector = aStartSector;

    const uint bufSizeSectors = sizeof(buf) / KDefSecSize;

    while(remSectors)
    {
        const uint secToRead = Min(remSectors, bufSizeSectors);
        buf[0] = ~aFill;

        nRes = VHD_ReadSectors(aVhdHandle, currSector, secToRead, buf, sizeof(buf));
        test_Val(nRes, (int)secToRead)

        if(!CheckFilling(buf, secToRead*KDefSecSize, aFill))
            return KErrCorrupt;

        remSectors -= secToRead;
        currSector += secToRead;
    }

    return KErrNone;
}

//--------------------------------------------------------------------
/**
    Fill a number of sectors from a VHD file.

    @param  aVhdHandle      VHD file file handle
    @param  aStartSector    statring sector
    @param  aNumSectors     number of secttors to write
    @param  aFill           filling byte

    @return KErrNone if the read sequence is the same as generated by aSeqGen. KErrCorrupt otherwise
*/
int LibVhd_2_FillFile(TVhdHandle aVhdHandle, uint aStartSector, uint aNumSectors, uint8_t aFill)
{
    TEST_LOG("vhdHandle:%d, aStartSector:%d, aNumSectors:%d, Fill:%d", aVhdHandle, aStartSector, aNumSectors, aFill);

    test(aVhdHandle > 0);
    test(aNumSectors > 0);

    int nRes;
    uint8_t buf[32*K1KiloByte];

    uint remSectors = aNumSectors;
    uint currSector = aStartSector;

    const uint bufSizeSectors = sizeof(buf) / KDefSecSize;

    memset(buf, aFill, sizeof(buf));

    while(remSectors)
    {
        const uint secToWrite = Min(remSectors, bufSizeSectors);

        nRes = VHD_WriteSectors(aVhdHandle, currSector, secToWrite, buf, sizeof(buf));
        test_Val(nRes, (int)secToWrite)

        remSectors -= secToWrite;
        currSector += secToWrite;
    }

    return KErrNone;
}



//--------------------------------------------------------------------
/**
    Create a fixed VHD file and print its properties by means of libvhd2.
    @param  aFileName       file name
    @param  aSizeInSectors  required VHD size in sectors; it is approximate value.
*/
void LibVhd_2_CreateVhd_Fixed(const char* aFileName, uint aSizeInSectors)
{
    TEST_LOG("FName:%s, sizeInSectors:%d", aFileName, aSizeInSectors);

    TVhdHandle hVhd;

    TVHD_ParamsStruct  params;
    memset(&params, 0, sizeof(params));

    params.vhdFileName = aFileName;
    params.vhdType = EVhd_Fixed;
    params.vhdSectors = aSizeInSectors;

    hVhd = VHD_Create(&params);

    TEST_LOG("VHD_Create() returned handle:%d", hVhd);

    test(hVhd > 0);

    char buf[8192];
    FillZ(buf);

    int nRes = VHD_PrintInfo(hVhd, buf, sizeof(buf));
    test_KErrNone(nRes);

    buf[sizeof(buf)-1] = '\0';

    TEST_LOG("file info:\n %s\n", buf);

    LibVhd_2_CloseVhd(hVhd);
}

//--------------------------------------------------------------------
/**
    Create a dynamic VHD file and print its properties by means of libvhd2.
    @param  aFileName       file name
    @param  aSizeInSectors  required VHD size in sectors; it is approximate value.
*/
void LibVhd_2_CreateVhd_Dynamic(const char* aFileName, uint aSizeInSectors)
{
    TEST_LOG("FName:%s, sizeInSectors:%d", aFileName, aSizeInSectors);

    TVhdHandle hVhd;

    TVHD_ParamsStruct  params;
    memset(&params, 0, sizeof(params));

    params.vhdFileName = aFileName;
    params.vhdType = EVhd_Dynamic;
    params.vhdSectors = aSizeInSectors;

    hVhd = VHD_Create(&params);

    TEST_LOG("VHD_Create() returned handle:%d", hVhd);

    test(hVhd > 0);

    char buf[8192];
    FillZ(buf);

    int nRes = VHD_PrintInfo(hVhd, buf, sizeof(buf));
    test_KErrNone(nRes);

    buf[sizeof(buf)-1] = '\0';

    TEST_LOG("file info:\n %s\n", buf);

    LibVhd_2_CloseVhd(hVhd);
}


/**
    Create a differencing VHD file and print its properties by means of libvhd2.
    @param  aFileName       file name
    @param  aParentFileName parent VHD file name
*/
void LibVhd_2_CreateVhd_Diff(const char* aFileName, const char* aParentFileName)
{
    TEST_LOG("FName:%s, ParentName:%s", aFileName, aParentFileName);

    TVhdHandle hVhd;

    TVHD_ParamsStruct  params;
    memset(&params, 0, sizeof(params));

    params.vhdFileName = aFileName;
    params.vhdType = EVhd_Diff;
    params.vhdParentName = aParentFileName;

    hVhd = VHD_Create(&params);

    TEST_LOG("VHD_Create() returned handle:%d", hVhd);

    test(hVhd > 0);

    char buf[8192];
    FillZ(buf);

    int nRes = VHD_PrintInfo(hVhd, buf, sizeof(buf));
    test_KErrNone(nRes);

    buf[sizeof(buf)-1] = '\0';

    TEST_LOG("file info:\n %s\n", buf);

    LibVhd_2_CloseVhd(hVhd);

}

//--------------------------------------------------------------------
/**
    Write a pseudo-random sequence of bytes to a previously opened VHD file. "libvhd2" is used.

    @param  aVhdHandle      VHD file file handle
    @param  aStartSector    statring sector
    @param  aNumSectors     number of secttors to write
    @param  aSeqGen         ref. to the sequence generator. The caller is responsible for maintaininig its state

*/
void LibVhd_2_WriteTestSequence(TVhdHandle aVhdHandle, uint aStartSector, uint aNumSectors, TRndSequenceGen& aSeqGen)
{
    TEST_LOG("vhdHandle:%d, aStartSector:%d, aNumSectors:%d", aVhdHandle, aStartSector, aNumSectors);

    test(aVhdHandle > 0);
    test(aNumSectors > 0);

    int nRes;
    uint8_t buf[32*K1KiloByte];

    uint remSectors = aNumSectors;
    uint currSector = aStartSector;

    const uint bufSizeSectors = sizeof(buf) / KDefSecSize;

    while(remSectors)
    {
        const uint secToWrite = Min(remSectors, bufSizeSectors);

        aSeqGen.GenerateSequence(buf, secToWrite*KDefSecSize);

        nRes = VHD_WriteSectors(aVhdHandle, currSector, secToWrite, buf, sizeof(buf));
        test_Val(nRes, (int)secToWrite)

        remSectors -= secToWrite;
        currSector += secToWrite;
    }

}

//--------------------------------------------------------------------
/**
    Read and verify a pseudo-random sequence of bytes from a VHD file. "libvhd2" is used.

    @param  aVhdHandle      VHD file file handle
    @param  aStartSector    statring sector
    @param  aNumSectors     number of secttors to read/verify
    @param  aSeqGen         ref. to the sequence generator. The caller is responsible for maintaininig its state

    @return KErrNone if the read sequence is the same as generated by aSeqGen. KErrCorrupt otherwise
*/
int LibVhd_2_CheckTestSequence(TVhdHandle aVhdHandle, uint aStartSector, uint aNumSectors, TRndSequenceGen& aSeqGen)
{
    TEST_LOG("vhdHandle:%d, aStartSector:%d, aNumSectors:%d", aVhdHandle, aStartSector, aNumSectors);

    test(aVhdHandle > 0);
    test(aNumSectors > 0);

    int nRes;
    uint8_t buf[32*K1KiloByte];

    uint remSectors = aNumSectors;
    uint currSector = aStartSector;

    const uint bufSizeSectors = sizeof(buf) / KDefSecSize;

    while(remSectors)
    {
        const uint secToRead = Min(remSectors, bufSizeSectors);

        FillZ(buf);

        nRes = VHD_ReadSectors(aVhdHandle, currSector, secToRead, buf, sizeof(buf));
        test_Val(nRes, (int)secToRead)

        nRes = aSeqGen.CheckSequence(buf, secToRead*KDefSecSize);
        if(nRes != KErrNone)
            return nRes;

        remSectors -= secToRead;
        currSector += secToRead;
    }

    return KErrNone;
}




//--------------------------------------------------------------------
/**
    Check that certain sectors of the VHD file are filled with the given sequence.
    libvhd2 is used.

    @param  aVhdHandle      VHD file file handle
    @param  aSectorList     an array of structures describing which sectors to check
    @param  aFill           aSeqGen pseudo-random sequence generator, in a proper state

    @return KErrNone if the read sequence is the same as generated by aSeqGen. KErrCorrupt otherwise
*/
int LibVhd_2_CheckSectorsFill(TVhdHandle aVhdHandle, vector<TSectorsBase>& aSectorList, TRndSequenceGen& aSeqGen)
{
    TEST_LOG();

    int nRes;

    test(aSectorList.size());
    for(uint i=0; i<aSectorList.size(); ++i)
    {
        const TSectorsBase& secStr = aSectorList[i];

        test(secStr.iSecNum);
        test(secStr.Type() != TSectorsBase::EInvalid);

        //-- check zero-filling
        if(secStr.Type() == TSectorsBase::EEmpty)
        {
            nRes = LibVhd_2_CheckFileFill(aVhdHandle, secStr.iSecStart, secStr.iSecNum, 0);
            if(nRes != KErrNone)
            {
                TEST_LOG("check failed !");
                return nRes;
            }
        }

        //-- check filling with the test sequence
        if(secStr.Type() == TSectorsBase::EFilled)
        {
            nRes = LibVhd_2_CheckTestSequence(aVhdHandle, secStr.iSecStart, secStr.iSecNum, aSeqGen);
            if(nRes != KErrNone)
            {
                TEST_LOG("check failed !");
                return nRes;
            }
        }
    }

    return KErrNone;
}


//-----------------------------------------------------------------------------
/**
    Check if a given buffer is filled with some byte.
    Uses a kind of binary search, dividing a buffer by halves and comparing them. This gives O(log2(N)) performance for the worst case.
    memcmp used here is supposed to be well-optimised to cope with various issues, like data alignment

    @param  apBuf       pointer to the buffer with data
    @param  aNumBytes   number of bytes to check
    @param  aFillByte   a fill pattren byte
    @return             true if whole buffer is filled with "aFillByte", false otherwise
*/
bool CheckFilling(const void* apBuf, uint32_t aNumBytes, uint8_t aFillByte)
{
    if(!aNumBytes)
    {
        return false;
    }

    const uint8_t* pBuf = (const uint8_t*)apBuf;

    if(pBuf[0] != aFillByte)
        return false;

    uint32_t len = aNumBytes >> 1; //-- current length of the half-buffers to compare

    if(!len)
        return true; //-- 1 byte array, and we have already checked it

    if(pBuf[0] != pBuf[aNumBytes-1])
        return false;  //-- this check is for the array with odd number of bytes

    const uint8_t* const p1 = pBuf;    //-- points to the 1st half of the buffer

    for(;;)
    {
        const uint8_t* p2 = pBuf + len;//-- points to the 2nd half of the buffer

        if(len == 1)
            return (*p1 == *p2);  //-- 2 last bytes left to compare

        if(memcmp(p1, p2, len))
            return false;   //-- 2 sub-arrays differ

        len >>= 1;

    }

}

//-----------------------------------------------------------------------------
/**
    Clean up test directory, make the best effort to delete leftover *.vhd files
*/
void Tests_Cleanup()
{
    std::string strCmd(KVhdFilesPath);

    strCmd += "*.vhd";
    strCmd.insert(0, "rm -f ");
    system(strCmd.c_str());

}













